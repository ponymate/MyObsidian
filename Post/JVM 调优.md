JVM调优主要是针对垃圾收集器的收集性能优化，减少GC的频率和Full GC的次数，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量和减少暂停时间。

**调优目标：**

- 堆内存使用率 <= 70%;
- 老年代内存使用率<= 70%;
- avg pause <= 1秒;
- Full GC 次数 0 或 avg pause interval >= 24小时 ;
- 创建更多的线程

遇到以下情况，就需要考虑进行JVM调优：

1. 系统吞吐量与响应性能不高或下降；
2. Heap内存（老年代）持续上涨达到设置的最大内存值；
3. Full GC 次数频繁；
4. GC 停顿时间过长（超过 1 秒）；
5. 应用出现OutOfMemory 等内存异常；
6. 应用中有使用本地缓存且占用大量内存空间；

- 优先原则：优先架构调优和代码调优，JVM优化是不得已的手段
- 大多数的Java应用不需要进行JVM优化
- 观测性原则：发现问题解决问题，没有问题不找问题

> 调优，还是得从实际出发，可能咋们写的代码，需要优化，或者我们的框架需要优化。
> 
> 调优，是不得已的手段了。

### JVM实践调优主要步骤

> 默认的策略是最普用，但不是最佳的。

- 第一步：监控分析GC日志
    
- 第二步：判断JVM问题：
    
    - 如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化
    - 如果GC时间超过1-3秒，或者频繁GC，则必须优化。
    
- 第三步：确定调优目标
    
- 第四步：调整参数
    
    - 调优一般是从满足程序的内存使用需求开始，之后是时间延迟要求，最后才是吞吐量要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。

- 第五步：对比调优前后差距
    
- 第六步：重复： 1 、 2 、 3 、 4 、 5 步骤
    
    - 找到最佳JVM参数设置

- 第七步：应用JVM到应用服务器：
    
    - 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。

  
Jvm调优典型参数设置;

1. **-Xms堆内存的最小值：**
    - 默认情况下，当堆中可用内存小于40%时，堆内存会开始增加，一直增加到-Xmx的大小。
2. **-Xmx堆内存的最大值：** 默认值是总内存/64（且小于1G）
    - 默认情况下，当堆中可用内存大于70%时，堆内存会开始减少，一直减小到-Xms的大小；
3. **-Xmn新生代内存的最大值：**
    - 1.包括Eden区和两个Survivor区的总和
    - 2.配置写法如：-Xmn1024k，-Xmn1024m，-Xmn1g
4. **-Xss每个线程的栈内存：**
    - 默认1M，一般来说是不需要改。线程栈越小意味着可以创建的线程数越多

整个堆的大小 = 年轻代大小 + 年老代大小，堆的大小不包含元空间大小，如果增大了年轻代，年老代相应就会减小，官方默认的配置为年老代大小/年轻代大小=2/1左右；

建议在开发测试环境可以用Xms和Xmx分别设置最小值最大值，但是在线上生产环境，**Xms和Xmx设置的值必须一样，防止抖动；**

**JVM调优设置合大小堆内存空间，既不能太大，也不能太小。那么应该设置为多少呢？**

默认的配置是否存在性能瓶颈。如果想要确定JVM性能问题瓶颈，需要进一步分析**GC日志**

1. **-XX:+PrintGCDetails** 开启GC日志创建更详细的GC日志 ，默认情况下，GC日志是关闭的
2. **-XX:+PrintGCTimeStamps，-XX:+PrintGCDateStamps** 开启GC时间提示
    - 开启时间便于我们更精确地判断几次GC操作之间的时两个参数的区别
    - 时间戳是相对于 0 （依据JVM启动的时间）的值，而日期戳（date stamp）是实际的日期字符串
    - 由于日期戳需要进行格式化，所以它的效率可能会受轻微的影响，不过这种操作并不频繁，它造成的影响也很难被我们感知。
3. **-XX:+PrintHeapAtGC** 打印堆的GC日志
4. **-Xloggc:./logs/gc.log** 指定GC日志路径

```
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-XX:+PrintGCDateStamps
-XX:+PrintHeapAtGC
-Xloggc:./logs/gc.log
```


#### GC日志分析

分析GC日志，就必须让GC日志输出到一个文件中，然后使用GC日志分析工具（[gceasy.io/](https://link.juejin.cn/?target=https%3A%2F%2Fgceasy.io%2F "https://gceasy.io/")) 进行分析

![[Pasted image 20230713200839.png]]

![[Pasted image 20230713200915.png]]

|Generation【区域】|Allocated【最大值】|Peak【占用峰值】|
|---|---|---|
|Young Generation【年轻代】|74.5 mb|74.47 mb|
|Old Generation【老年代】|171 mb|95.62 mb|
|Meta Space【元空间】|1.05 gb|55.38 mb|
|Young + Old + Meta space【整体】|1.3 gb|212.64 mb|

![[Pasted image 20230713201409.png]]

1 、**吞吐量**： 百分比越高表明GC开销越低。这个指标反映了JVM的吞吐量。

- **Throughput**：**99.983%**

2 、**GC 延迟**：**Latency**

- Avg Pause GC Time： 43.80 ms** 平均GC暂停时间
- Max Pause GC Time： **230 ms** 最大GC暂停时间

![[Pasted image 20230713201652.png]]

由上图可以看到，发生了5次full gc

存在问题：一开始就发生了 5 次full gc , 很明显不太正常；

![[Pasted image 20230713201826.png]]

![[Pasted image 20230713201835.png]]

|原因|次数|平均时间|最大时间|总耗时|
|---|---|---|---|---|
|Metadata GC Threshold（元空间超阈值）|10|74.0 ms|230 ms|740 ms|
|Allocation Failure（年轻代空间不足）|15|19.3 ms|70.0 ms|290 ms|
|GCLocker Initiated GC|5|52.0 ms|80.0 ms|260 ms|

#### 堆内存与元空间优化

老年代的空间峰值大小为0.22g=255m

- 堆内存：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。
    - 255* (3-4) = (765-1020)MB ，设置heap大小为1020MB；
- 元空间：参数-XX:MetaspaceSize=N，设置元空间大小为128MB;
- 参数-Xmn可以设置为1-1.5倍FullGC之后的老年代空间占用 ，**一般采用默认比例。或者255M*(1-1.5)=(255-382)M，设置新生代大小为382MB；
    - 不设置：新生代和老年代比例：1 : 2
- -XX:NewRetio = 4 表示young和old所占比值为1:4，**一般采用默认比例。**

```
`# 调整参数，基于当前系统运行情况这是最佳配置 
JAVA_OPT="${JAVA_OPT} -Xms1020m -Xmx1020m -Xmn382m -XX:MetaspaceSize=128m" 
# -Xms堆最小内存 
# -Xmx堆最大内存 
# -Xmn新生代大小： 
# -XX:MetaspaceSize元空间大小`
```

```
-Xms1020m -Xmx1020m -Xmn382m -XX:MetaspaceSize=128m
```

再次查看GC日志分析，进行对比，对比GC频率和每次GC的时间。

#### 线程栈优化

> -Xss每个线程的栈内存：默认1M，一般来说是不需要改的

这里要如何设置-Xss的值呢？这里有一个公式：

最大的线程数的影响因素： Max Of Thread  = (机器本身可用内存 -(JVM分配的堆内存+JVM元数据区)) / Xss值`

**机器环境：**

|指标|参数|
|---|---|
|机器|CPU 12核，内存16GB|
|集群规模|单机|
|seqb_web版本|1.0|
|数据库|4核 16G|

由上面的公式，我们计算一下：

- 机器本身可用内存：机器内存16G
- JVM分配的堆内存：1020m (上面堆内存调优的值)
- JVM元数据区：128m (上面堆内存调优的值)

最大的线程数的影响因素： 
Max Of Thread  = (机器本身可用内存 -(JVM分配的堆内存+JVM元数据区)) / Xss值

开启一个线程，需要占用的内存1m 
(16384 - (1020+128)) / 1m = 15,236个   (16384 - (1020+128)) / 0.5m = 30,472个线程数 
理论大小上限：现在可以不加16GB内存，也让当前值理论最大线程数翻倍

**那么问题来了，Xss应该设置多少呢？**

JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为 256k 。

更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。

但是操作系统对一个进程内的线程数还是有限制的，不能无限生成， **1w~2w左右** 一般小的应用， 如果栈不是很深， 应该是 **512k够用** 了，大的应用建议使用1m。

注意：这个选项对性能影响较大，需要严格的测试确定最终大小。

```
JAVA_OPT="${JAVA_OPT} -Xms1020m -Xmx1020m -Xmn382m -XX:MetaspaceSize=128m -Xss512k"
```

#### 垃圾回收器优化

![[Pasted image 20230713205147.png]]

1. **吞吐量优先ps+po**

- Perallel-Scavenge垃圾收集器：`-XX:+UsePerallelGC`
    - 吞吐量优先
    - 年轻代是并行回收的，老年代是串行回收的【STW】
    - 新生代收集器复制算法，老年代采用的是标记-整理算法【mark-compart】
    - 并行的多线程收集器
- Perallel-Old垃圾收集器【po是ps的老年代并行收集版本】：`-XX：+UsePerallelOldGC`
    - 吞吐量优先
    - 老年代采用并行垃圾回收

默认使用 `ps+po` 垃圾回收器组合： 并行垃圾回收器组合

```ini
JAVA_OPT="${JAVA_OPT} -XX:+UseParallelGC -XX:+UseParallelOldGC 
```

可以使用Jmeter，进行压力测试，看看平均响应时间，查看GC的频率和平均时间：

2. **响应时间优先parnew+cms**

- ParNew垃圾收集器【Serial的收集器的多线程版本】：`-XX:UseParNewGC`
    - 年轻代是并行的垃圾回收，老年代是串行垃圾回收
    - 注意：单核的CPU性能并不如Serial，没有线程切换成本
- CMS垃圾收集器： 并发 收集器(非独占式)`-XX:ConcMarkSweepGC`【并发的标记清楚算法的GC垃圾收集器】
    - 响应优先(低延时)
    - 可以执行并发收集的垃圾收集器
    - 垃圾收集采用的是标记清除算法
    - 缺点：容易产生内存碎片，对CPU比较敏感
    - 主要分为四个阶段：
        1. **初始标记（Initial-Mark）阶段** ：【STW】
        2. **并发标记（Concurrent-Mark）阶段** ：
        3. **重新标记（Remark）阶段** ：【STW】
        4. **并发清除（Concurrent-Sweep）阶段** ：

使用cms垃圾回收器，垃圾回收器组合： parNew+CMS, cms垃圾回收器在垃圾标记，垃圾清除的时候，和业务线程交叉执行，尽量减少stw时间，因此这垃圾回收器叫做`响应时间优先`；

```
JAVA_OPT="${JAVA_OPT} -XX:+UseParNewGC -XX:+UseConcMarkSweepGC
```

3. **G1垃圾收集器（重点）**

**Garbage First（简称G1）** 收集器是垃圾收集器技术发展历史上的里程碑式的成果

JDK 8以后G1收集器才被Oracle官方称为“全功能的垃圾收集器”（Fully-Featured Garbage Collector）。

G1是一款主要面向服务端应用的垃圾收集器。

JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器。

> 由此可见，G1变得越来越重要了。CMS变成了中间过度。

G1中提供了三种模式垃圾回收模式， **Young GC、Mixed GC 和 Full GC** ，在不同的条件下被触发。

G1的使用步骤：

- 配置开启G1
- 设置对的最大内存
- 设置GC最大暂停时间：设置100-300之间是比较合理：
    - 如果设置的GC的暂停时间比较小，系统吞吐量会降低
    - 默认的值是200,
    - G1设计的目标：控制用户线程执行时间90%，GC占比时间10%

```
JAVA_OPT="${JAVA_OPT} -XX:+UseG1GC -XX:MaxGCPauseMillis=100" 
# MaxGCPauseMillis设置的值建议是100-300之间
```

#### 文章推荐

[GC问题的分析和解决](https://tech.meituan.com/2020/11/12/java-9-cms-gc.html)

[JVM参数配置说明](https://help.aliyun.com/document_detail/148851.html)