1. 一条 SQL 语句在 MySQL 中如何执行的？
2. MySQL 数据库两种存储引擎的区别?
3. 事务的四大特性了解么?
4. MySQL 事务隔离级别？默认是什么级别？
5. 乐观锁与悲观锁的区别?
6. MVCC 是什么，作用？
7. 为什么索引能提高查询速度?
9. 使用索引一定能提高查询性能吗?
10. 索引底层的数据结构了解么？Hash 索引、 B+树索、红黑树引优劣分析
11. 什么是覆盖索引
12. 聚集索引和非聚集索引的区别？非聚集索引一定回表查询吗?
13. 最左前缀匹配原则了解么？
14. binlog
15. redo log
16. undo log
17. binlog 和 redo log 区别
18. 两阶段提交

## MySQL 基础架构

### SQL语句的执行过程

![[13526879-3037b144ed09eb88.png]]

简单来说 MySQL 主要分为 Server 层和存储引擎层：

1. 连接器，连接器主要用来身份认证和权限验证相关的功能。
2. 查询缓存(MySQL 8.0 版本后移除)
3. 分析器，MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，进行词法分析和语法分析
4. 优化器，优化器的作用就是它认为的最优的执行方案去执行，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。
5. 执行器，执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。

-   MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。
-   引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。
-   查询语句的执行流程如下：查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
-   更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎--->redo log(prepare 状态)--->binlog--->redo log(commit状态)

### MySQL 存储引擎

MySQL 核心在于存储引擎，MySQL 存储引擎采用的是 **插件式架构** ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。**存储引擎是基于表的，而不是数据库。**

MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎。

MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。

**总结** ：

-   MyISAM 不支持外键，而 InnoDB 支持。
-   MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。
-   InnoDB 支持行级锁，MyISAM 只支持表级锁。
-   MyISAM 不支持 MVVC，而 InnoDB 支持。
-   InnoDB 的性能比 MyISAM 更强大。
-   MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。

## MySQL 事务

### ACID

**只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！** 

-   Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
    
-   Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
    
-   Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
    
-   Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 事务隔离级别

1. 脏读

读取到了没有提交的脏的错误的数据。

例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。

2. 丢失修改

两个事务同时修改一个数据可能导致有一个事务的修改丢失。

例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。

3. 不可重复读

两个事务同时执行的时候，其中一个事务可能两次读取到的内容不一样

例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。

4. 幻读

两个事务同时执行的时候，其中一个事务可能两次读取到的数据数量不一样

例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。

SQL 标准定义了四个隔离级别：

-   **READ-UNCOMMITTED(读取未提交)** ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
-   **READ-COMMITTED(读取已提交)** ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
-   **REPEATABLE-READ(可重复读)** ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
-   **SERIALIZABLE(可串行化)** ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。

但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：

-   **快照读** ：由 MVCC 机制来保证不出现幻读。
-   **当前读** ：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是记录锁（Record Lock）和间隙锁（Gap Lock）的结合，可以锁住当前行和新加的行。

**快照读**（一致性非锁定读）就是单纯的 `SELECT` 语句，但不包括下面这两类 `SELECT` 语句：

```sql
SELECT ... FOR UPDATE
SELECT ... LOCK IN SHARE MODE
```

快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。

只有在事务隔离级别 读取已提交 和 可重读 下，InnoDB 才会使用快照读，快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。

**当前读** （一致性锁定读）就是给行记录加 X 锁或 S 锁。

当前读的一些常见 SQL 语句类型如下：

```sql
# 对读的记录加一个X锁
SELECT...FOR UPDATE
# 对读的记录加一个S锁
SELECT...LOCK IN SHARE MODE
# 对修改的记录加一个X锁
INSERT...
UPDATE...
DELETE...
```

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ-COMMITTED** ，但是你要知道的是 InnoDB 存储引擎默认使用 **REPEATABLE-READ** 并不会有任何性能损失。

InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。

MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。

SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的， 但是REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。

### MVCC

MVCC（Multi-Version Concurrency Control）是一种多版本并发控制技术，用于支持数据库的并发访问。

MVCC 的原理是，在每个数据行上维护多个版本，每个版本都有一个时间戳。

当一个事务要读取一个数据行时，数据库系统会根据该事务的时间戳，选择一个与该事务兼容的版本
-   在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。
-   在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。

如果该事务要修改数据行，则系统会为该事务创建一个新版本，并将新版本的时间戳设置为当前时间戳，从而保证其他事务读取到的是旧版本的数据，而不会干扰到该事务的修改操作。

### 锁

1. 表级锁、行级锁

-   **表级锁：** 是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。
-   **行级锁**： 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁，当我们执行``update``，``delete``语句时，如果where条件中字段没有命中索引或者索引失效的话，就会导致扫描全表对表中的所有记录进行加锁。 行级锁能大大减少数据库操作的冲突，并发度高，但锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。

行级锁包括：

-   **记录锁（Record Lock）** ：属于单个行记录上的锁。
-   **间隙锁（Gap Lock）** ：锁定一个范围，不包括记录本身。
-   **临键锁（Next-Key Lock）** ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。

在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 临键锁。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 临键锁 进行优化，将其降级为 记录锁，即仅锁住索引本身，而不是范围。

2. 共享锁、排他锁

不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：

-   **共享锁（S 锁）** ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取。
-   **排他锁（X 锁）** ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。

3. 意向锁

意向锁在MySQL中用于协调多个事务对同一表的并发访问，帮助管理锁的获取顺序，减少冲突和死锁的可能性。

意向锁是表级锁，共有两种：

-   **意向共享锁（Intention Shared Lock，IS 锁）**：加共享锁前必须先取得该表的 IS 锁。
-   **意向排他锁（Intention Exclusive Lock，IX 锁）**：加排他锁之前必须先取得该表的 IX 锁。

意向锁之间是互相兼容的。

![[Pasted image 20230302165644.png]]

## MySQL 索引

### 索引的优缺点

**优点** ：

-   使用索引可以大大加快数据的检索速度, 这也是创建索引的最主要的原因。
-   通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

**缺点** ：

-   创建索引和维护索引需要耗费时间。当对表中的数据进行增删改的时候，索引也需要动态的修改，会降低 SQL 执行效率。
-   索引需要使用物理文件存储，也会耗费一定空间。

大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。

### 索引的数据结构

1. Hash 表

主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。

2. B 树 & B+树

**多路平衡查找树**

MySQL使用B+树作为索引的原因是因为B+树有以下几个优点：

-   B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
-   B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。

1.  B+树具有更好的数据分布性：B+树通过调整每个节点中存储的键值数量，使得每个节点的大小都能够适应磁盘块的大小，这样就能够充分利用磁盘空间，减少了存储空间的浪费。

2.  B+树支持高效的范围查询：由于所有数据都存储在叶子节点中，因此在进行范围查询时，只需要从起始节点开始顺序读取即可，不需要像其他树结构那样在不同的节点之间跳跃。

二叉查找树、平衡二叉树、红黑树等树结构具有随机的节点大小，导致存储空间的浪费和磁盘访问的效率降低。

### 索引类型

按照底层存储方式角度划分：

-   聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
-   非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

按照应用维度划分：

- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- 普通索引：仅加速查询。
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

**1.聚簇索引、非聚簇索引**

**聚簇索引即索引结构和数据一起存放的索引。InnoDB 中的主键索引就属于聚簇索引。** 对于 InnoDB 引擎表来说，该表的索引的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

**非聚簇索引即索引结构和数据分开存放的索引。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。** 非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

对比 ：

-   **查询速度** ：聚簇索引的查询速度非常的快。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。非聚簇索引当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

-   **更新代价** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。

**非聚簇索引也不一定要回表查询(覆盖索引)**

**2.主键索引，二级索引**

一张数据表有只能有一个主键，并且主键不能为 null（普通索引和唯一索引都可以为null），不能重复。

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。

二级索引又称为辅助索引，二级索引的叶子节点存储的数据是主键。

唯一索引，普通索引，前缀索引等索引属于二级索引。

**3.覆盖索引**

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”。

**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。**

**4.联合索引**

使用表中的多个字段创建索引，就是 **联合索引**，也叫 **组合索引** 或 **复合索引**。

### 最左前缀匹配原则

在使用联合索引时，**MySQL** 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **`>`**、**`<`**）才会停止匹配。对于 **`>=`**、**`<=`**、**`BETWEEN`**、**`like`** 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

## MySQL 日志

InnoDB 引擎使用 `redo log` 保证事务的 持久性，使用 `undo log` 来保证事务的 原子性，使用`binlog` 进行数据库的数据备份、主备、主主、主从，同步数据，保证数据一致性。

- binlog和redo log 有什么区别

1.  记录内容不同：binlog主要记录了对数据库的更新操作，包括insert、update、delete等语句，而redo log则记录了数据库的物理修改操作，包括对磁盘上的数据页的修改。
    
2.  目的不同：binlog的主要目的是为了实现数据恢复、数据同步、数据库备份和性能分析等功能，而redo log的主要目的是为了在发生崩溃等异常情况时保证数据库的一致性和可靠性。
    
3.  写入方式不同，binlog 只有在事务完成之后才写入磁盘，而 redo log 至少每隔一秒后台就会将内容写入磁盘。
	
4. binlog 是 server 层包含的，所有存储引擎都有，而 redo log 为 InnoDB 独有的。

### binlog

binlog是记录所有涉及更新数据的逻辑操作。属于`MySQL Server` 层，不依赖于存储引擎。

binlog的主要用途是保证数据一致性，包括：

1.  数据恢复：在发生错误或数据损坏时，可以使用binlog进行数据恢复，以将数据恢复到之前的状态。
    
2.  数据同步：在使用主从复制时，主库将修改操作写入binlog，从库通过解析binlog来同步数据。
    
3.  数据库备份：binlog可以用于备份数据库，以便在需要时进行数据恢复。
    
4.  性能分析：通过分析binlog中的SQL语句，可以了解数据库的访问情况和性能瓶颈，以优化数据库性能。

`binlog` 在事务执行过程中，先把日志写到 `binlog cache`，事务提交的时候，再把`binlog cache`写到`binlog`文件中。

`binlog`日志刷盘流程如下

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234747840.png)

- 上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快
    
- 上图的 fsync，才是将数据持久化到磁盘的操作

`write`和`fsync`的时机，可以由参数`sync_binlog`控制，默认是`0`。

为`0`的时候，表示每次提交事务都只 `write`，由系统自行判断什么时候执行`fsync`。虽然性能得到提升，但是机器宕机，`page cache`里面的 binlog 会丢失。

为了安全起见，可以设置为`1`，表示每次提交事务都会执行`fsync`，就如同 **redo log 日志刷盘流程** 一样。如果设置为`N(N>1)`，表示每次提交事务都`write`，但累积`N`个事务后才`fsync`。

在出现`IO`瓶颈的场景里，将`sync_binlog`设置成一个比较大的值，可以提升性能，但是如果机器宕机，会丢失最近`N`个事务的`binlog`日志

### redo log

`MySQL` 中数据是以页为单位，查询一条记录会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 `Buffer Pool` 中。后续的查询都是先从 `Buffer Pool` 中找，没有命中再去硬盘加载，减少硬盘 `IO` 开销，提升性能。更新表数据的时候，发现 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。

redo log 记录 “在某个数据页上做了什么修改” ，是 `InnoDB` 存储引擎独有的，它让`MySQL`拥有了崩溃恢复能力。比如 MySQL 实例挂了或宕机了，重启时，`InnoDB`存储引擎会使用`redo log`恢复数据，保证数据的持久性与完整性。

在事务执行过程中 `redo log` 记录会被写入 `redo log buffer` 中，然后根据刷盘策略被后台线程刷盘。

`InnoDB` 存储引擎为 `redo log` 的刷盘策略提供了 `innodb_flush_log_at_trx_commit` 参数，它支持三种策略：

- **0** ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作
    
- **1** ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）
    
- **2** ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache

另外，`InnoDB` 存储引擎有一个后台线程，每隔`1` 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。

并且当 `redo log buffer` 占用的空间即将达到 `innodb_log_buffer_size` 一半的时候，后台线程会主动刷盘。

下面是不同刷盘策略的流程图。

**innodb_flush_log_at_trx_commit=0**

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/06.png)

为`0`时，如果`MySQL`挂了或宕机可能会有`1`秒数据的丢失。

**innodb_flush_log_at_trx_commit=1**

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/07.png)

为`1`时， 只要事务提交成功，`redo log`记录就一定在硬盘里，不会有任何数据丢失。

如果事务执行期间`MySQL`挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。

**innodb_flush_log_at_trx_commit=2**

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/09.png)

为`2`时， 只要事务提交成功，`redo log buffer`中的内容只写入文件系统缓存（`page cache`）。

如果仅仅只是`MySQL`挂了不会有任何数据丢失，但是宕机可能会有`1`秒数据的丢失。

- 页修改之后为什么不直接刷盘呢

性能非常差！InnoDB页的大小一般为16k，而页又是磁盘和内存交互的基本单位。这就导致即使我们只修改了页中的几个字节的数据，一般磁盘操作也需要将16KB大小的页整个都刷新到磁盘中，而且，这些修改的页可能并不相邻，也就是说这还可能是随机IO。

### undo log

为了保证事务的原子性，需要在异常发生时，对已经执行的操作进行**回滚**，在 MySQL 中，回滚机制是通过 undo log 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。当程序遇到异常时，可以直接利用 undo log 中的信息将数据回滚到修改之前的样子。

并且，undo log 会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询 undo log 回滚之前未完成的事务。

### 两阶段提交

`redo log` 让 `InnoDB` 存储引擎拥有了崩溃恢复能力。

`binlog` 保证了 `MySQL` 集群架构的数据一致性。

虽然它们都属于持久化的保证，但是侧重点不同。

在执行更新语句过程，会记录`redo log`与`binlog`两块日志，以基本的事务为单位，`redo log`在事务执行过程中可以不断写入，而`binlog`只有在提交事务时才写入，所以`redo log`与`binlog`的写入时机不一样。

如果 `binlog` 没写完就异常，这时候`binlog`里面没有对应的修改记录。因此，之后用`binlog`日志恢复数据时，就会少这一次更新，而原库因为`redo log`日志恢复，最终数据不一致。

于是将 `redo log` 的写入拆成了两个步骤 `prepare` 和 `commit`，这就是**两阶段提交**。

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234956774.png)

使用**两阶段提交**后，写入`binlog`时发生异常也不会有影响，因为`MySQL`根据`redo log`日志恢复数据时，发现`redo log`还处于`prepare`阶段，并且没有对应`binlog`日志，就会回滚该事务。

![](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/06-20220305234907651.png)

如果 `redo log` 在 `commit` 阶段发生异常，也不会回滚事务，根据上图，`MySQL` 能通过事务`id`找到对应的`binlog`日志，所以`MySQL`认为是完整的，就会提交事务。