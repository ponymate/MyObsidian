## Redis 数据结构

Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。

**1.String**

Redis 自己构建了一种 **简单动态字符串**（Simple Dynamic String，**SDS**）。

SDS 相比于 C 语言中的字符串有如下提升：

1.  **可以避免缓冲区溢出** ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。
2.  **获取字符串长度的复杂度较低** ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。
3.  **减少内存分配次数** ： C 语言修改字符串时，每次都需要重新分配内存，SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会根据特定的算法分配多余的内存，减少后续内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用，也支持手动释放。
4.  **二进制安全** ：C 语言中的字符串以空字符 `\0` 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。

**2.Hash**

适合对象数据存储，并且频繁操作个别属性的场景。

-   String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。
-   String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。

在绝大部分情况，我们建议使用 String 来存储对象数据即可！

**3.Set**

Set 可以实现交集、并集、差集的操作，比如共同关注、共同粉丝、共同喜好、好友推荐等功能，并且包含随机获取集合中元素的功能。

适合需要存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 `HyperLogLog`更适合一些）、文章点赞、动态点赞等场景。

适合需要随机获取数据源中的元素的场景：抽奖系统、随机。

**4.ZSet**

适合需要存储的数据有优先级或者重要程度的场景：排行榜。

**5.Bitmap**

Bitmap 可以看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。
![[image-20220720194154133.png]]

需要保存状态信息（0/1 即可表示）的场景：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。

**6.HyperLogLog**

用于基数统计，没有直接存储原数据，而是通过一定的概率统计方法预估集合中包含元素的个数。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差。

适合数量量巨大（百万、千万级别以上）的计数场景：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计

**7.Geospatial index**

地理空间索引，简称 GEO，主要用于存储地理位置信息。

## Redis 线程模型

对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求，来提高网络 IO 的读写性能。

**Redis6.0 之前不使用多线程的原因：** 

-   单线程编程容易并且更容易维护；
-   Redis 的性能瓶颈不在 CPU ，主要在内存和网络；
-   多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。

**Redis6.0 引入多线程主要是为了提高网络 IO 读写性能**，Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。

但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启

## Redis 内存管理

### 过期数据的删除策略

1.  **惰性删除** ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
2.  **定期删除** ：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。

定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 **定期删除+惰性删除** 。

### 内存淘汰策略

> 相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?

Redis 提供 6 种数据淘汰策略：

1.  **volatile-lru**：从已设置过期时间的数据中挑选最近最少使用的数据淘汰
2.  **volatile-ttl**：从已设置过期时间的数据中挑选将要过期的数据淘汰
3.  **volatile-random**：从已设置过期时间的数据中任意选择数据淘汰
4.  **volatile-lfu（least frequently used）**：从已设置过期时间的数据中挑选最不经常使用的数据淘汰

6.  **allkeys-lru**：从所有的数据集中移除最近最少使用的 key（这个是最常用的）
7.  **allkeys-random**：从数据集中任意选择数据淘汰
8.  **allkeys-lfu（least frequently used）**：从数据集中移除最不经常使用的 key

## Redis 持久化

Redis 有两种持久化方式：

- RDB（Redis Database Backup File）
- AOF（Append Only File）

**1.RDB** 

通过创建快照来获得数据在某个时间点上的副本，可以用于 Redis 主从节点的数据复制，还可以将快照留在原地以便重启服务器的时候使用。

RDB是 Redis 默认采用的持久化方式

Redis 提供了两个命令来生成 RDB 快照文件：

-   `save` : 主线程执行，会阻塞主线程；
-   `bgsave` : 子线程执行，不会阻塞主线程，默认选项。

**2.AOF**

每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 `server.aof_buf` 中，然后再根据 `appendfsync` 配置来决定何时将其同步到硬盘中的 AOF 文件。

与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。

当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。

**RDB 比 AOF 优秀的地方** ：

-   RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。
-   使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。

**AOF 比 RDB 优秀的地方** ：

-   RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的。AOF 支持秒级数据丢失，仅仅是追加命令到 AOF 文件，操作轻量。
-   AOF 文件的可读性比较好，可以直接对aof文件进行分析。

## Redis 事务

**Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。**

Redis 事务不支持回滚，因此不满足原子性的。

除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。因此，Redis 事务是不建议在日常开发中使用的。

可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。但是Lua 脚本也不支持回滚，不满足原子性。

如何减少网络传输开销的性能（即发送命令和结果返回的时间）：

**1.使用批量操作命令**

在 Redis Cluster 下，使用批量操作命令可能依然会出现多次网络传输的情况，也无法保证命令的原子性。就比如说 `mget` 无法保证所有的 key 都在同一个 **hash slot**（哈希槽）上，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。

如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。

**2.Lua 脚本**

一段 Lua 脚本可以视作一条命令执行，执行过程中不会有其他脚本或 Redis 命令同时执行。

-   如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，不能实现类似数据库回滚的原子性。
-   Redis Cluster 下 Lua 脚本的原子操作也无法保证了，因为无法保证所有的 key 都在同一个 **hash slot**（哈希槽）上。

## Redis 生产问题

### 大量 key 集中过期问题

Redis 采用 **定期删除+惰性删除** 策略来删除过期key。

定期删除执行过程中，如果突然遇到大量过期 key 的话，必须等待清理任务执行完成，因为定期任务是在 Redis 主线程中执行的。容易阻塞用户线程。

解决方法：

1.  给 key 设置随机过期时间。
2.  开启 lazy-free（惰性删除/延迟释放），让 Redis 采用异步方式延迟释放过期的 key ，操作由子线程处理，避免阻塞主线程。

### 缓存穿透

缓存穿透就是大量请求的 key **不存在于缓存中，也不存在于数据库中** 。这些请求对数据库造成了巨大的压力，可能造成服务器宕机。

![[redis-cache-penetration.png]]

有哪些解决办法？

**1）缓存无效 key**

如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，这种方式可以解决请求的 key 变化不频繁的情况。但是如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key，所以不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。

**2）布隆过滤器**

布隆过滤器可以非常方便地判断一个给定数据是否存在于海量数据中。

把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会查询Redis和数据库。

**布隆过滤器判断某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

### 缓存击穿

缓存击穿中，请求的 key 对应的是 **某个热点数据** ，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）** 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

![[redis-cache-penetration 1.png]]

举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。

有哪些解决办法？

-   设置热点数据永不过期或者过期时间比较长。
-   针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。
-   请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。

### 缓存雪崩

实际上，缓存雪崩描述的就是这样一个简单的场景：**缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。**

另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。

![[redis-cache-avalanche.png]]

举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。

有哪些解决办法？

**针对 Redis 服务不可用的情况：**

1.  采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2.  限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1.  设置不同的失效时间比如随机设置缓存的失效时间。
2.  设置二级缓存。

### Redis和数据库数据的一致性

**Cache Aside Pattern（旁路缓存模式）**

**Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。**

Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。

下面我们来看一下这个策略模式下的缓存读写步骤。

**写** ：

-   先更新 db
-   然后直接删除 cache 。

**读** :

-   从 cache 中读取数据，读取到就直接返回
-   cache 中读取不到的话，就从 db 中读取数据返回，再把数据放到 cache 中。

“**在写数据的过程中，可以先删除 cache ，后更新 db 么？**”

**答案：** 那肯定是不行的！因为这样可能会造成 **数据库（db）和缓存（Cache）数据不一致**的问题。

> 请求 1 先把 cache 中的 A 数据删除 -> 请求 2 从 db 中读取数据->请求 1 再把 db 中的 A 数据更新 -> 请求2将旧数据写入缓存

“**在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？**”

**答案：** 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。

> 请求 1 从 db 读数据 A-> 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -> 请求 1 将数据 A 写入 cache

**Cache Aside Pattern 的缺陷**。 

**缺陷 1：首次请求数据一定不在 cache 的问题**

解决办法：可以将热点数据可以提前放入 cache 中。

**缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。**

解决办法：

-   数据库和缓存数据强一致场景 ：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。
-   可以短暂地允许数据库和缓存数据不一致的场景 ：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。

### 热点key

热key可能会造成整体流量的不均衡，个别节点出现OPS过大的情况，极端情况下热点key甚至会超过 Redis本身能够承受的OPS。

对热key的处理，最关键的是对热点key的监控，可以从这些端来监控热点key:

1. 客户端  
    客户端其实是距离key“最近”的地方，因为Redis命令就是从客户端发出的，例如在客户端设置全局字典（key和调用次数），每次调用Redis命令时，使用这个字典进行记录。
    
2. 代理端  
    像Twemproxy、Codis这些基于代理的Redis分布式架构，所有客户端的请求都是通过代理端完成的，可以在代理端进行收集统计。
    
3. Redis服务端  
    使用monitor命令统计热点key是很多开发和运维人员首先想到，monitor命令可以监控到Redis执行的所有命令。

只要监控到了热key，对热key的处理就简单了：

1. 把热key打散到不同的服务器，降低压⼒
    
2. 加⼊⼆级缓存，提前加载热key数据到内存中，如果redis宕机，⾛内存查询

>缓存预热

1、直接写个缓存刷新页面或者接口，上线时手动操作

2、数据量不大，可以在项目启动的时候自动进行加载

3、定时任务刷新缓存

>热点key重建

- 当前key是一个热点key，并发量非常大。重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次IO、多个依赖等。 在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。

所以一般采用如下方式：

1. 互斥锁（mutex key）  
    这种方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。
2. 永远不过期  
    “永远不过期”包含两层意思：

- 从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。
- 从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。

## Redis 集群

### 主从复制

Redis 的同步过程分为：全量复制和部分复制。

**全量复制**  

一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。

**部分复制**  

部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区中有这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。

主从复制虽好，但也存在一些问题：

- 一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预。
- 主节点的写能力受到单机的限制。
- 主节点的存储能力受到单机的限制。

第一个问题是Redis的高可用问题，第二、三个问题属于Redis的分布式问题。

### Redis Sentinel

**1. Sentinel是什么，有什么作用？**

Redis Sentinel 是 Redis 的一种运行模式，依赖于 Redis 工作，实现Redis集群高可用，在主从复制实现集群的基础上，多了一个Sentinel角色来帮助我们监控 Redis 节点的运行状态并自动实现故障转移。

Redis Sentinel ，它由两部分组成，哨兵节点和数据节点：

- **哨兵节点：** 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据，对数据节点进行监控。
- **数据节点：** 主节点和从节点都是数据节点；

1. 监控：监控所有的redis节点（包括sentinel节点自身）的状态是否正常。
2. 故障转移：如果一个master出现故障，Sentinel会帮助我们实现故障转移，自动将某一台slave升级为master，确保整个Redis系统的可用性。
3. 通知：通知slave新的master连接信息，成为新的master的slave。
4. 配置提供：客户端连接sentinel请求master的地址，如果发生故障转移，sentinel会将新的master链接信息通知给客户端。

**2. Sentinel如何判断节点是否下线**

每个 sentinel 节点 每一秒钟一次的频率向整个集群中的 master、slave 以及其他的 sentinel 系欸但那发送一个 PING 命令。如果对应的节点超过规定时间没有进行有效回复的话，就被认为是主观下线。

如果slave被认为主观下线的话，sentinel 不会做什么事情，如果 mater 被认为主观下线的话，sentinel整体要进行合适，确保 master 是否真的下线

1. 主观下线：sentinel节点认为某个Redis节点已经下线了，但还不确定，需要其他sentinel节点的投票
2. 客观下线：法定数量（通常为过半的sentinel节点认为某个Redis节点已经下线，那就是真的下线了。

**3. Sentinel如何选出新的master**

1. slave优先级，可以通过修改配置文件来手动设置slave的优先级，默认为100，越小越有机会成为master。0表示没有机会成为master。

2. 复制进度：Sentinel总是希望选择出数据最完整的节点为master，复制进度越快得分越高

3. runnid（运行id）如果优先级和复制进度都一样，那么runid小的成为新的master，每个redis节点启动时都有一个40字节的随机字符串作为运行id。

**4. 脑裂问题**

假设一个集群有 M1，R2，R3。如果M1和R2和R3之间的网络被隔离，就是发生了脑裂。这时，R2或者R3的其中一个会被选举为master。网络分区恢复之后，M1可能将会成为slave节点，如果M1和客户端C1在同一个网络内，那么从网络被隔离到网络分区恢复的这段时间，C1写入M1的数据都会丢失，并且分区恢复后，C1读取的也可能是过时的数据。

可以通过修改配置文件来防止脑裂：
1. `min-replicas-to-write 1` 用于配置写 master 至少写入的slave数量，设置0表示关闭该功能。3节点的情况下，可以配置为1，表示master必须写入至少1个slave，否则就停止接受新的写入命令请求
2.  `min-replicas-max-lag 10` 用于配置 master 多长时间（秒）无法得到从节点的相应，就认为这个节点失联。这里是 如果master 10 秒都得不到一个从节点的相应，就会认为这个从节点失联，停止接收新的写入命令请求。

但是这样会 Redis 服务的整体可用性，如果两个slave都挂掉，master将会停止接受新的命令请求。

### Redis Cluster

**1. 为什么需要 Cluster，解决了什么问题，有什么优势**

缓存数据量太大，或者并发量要求太大。

主从复制和 Redis Sentinel 两种方案本质都是通过增加从节点 slave 的数量来提高 Redis 服务的整体可用性和读吞吐量，都不支持横向拓展来缓解写压力以及解决缓存数据量过大的问题。

Redis Cluster 就是部署多台 Redis 主节点，这些节点之间平等，同时对外提供读/写服务，缓存的数据相对均匀的分布在这些 Redis 实例上，客户端的请求通过路由规则转发到目标master上。

为了保证集群高可用，可以给每一个master配置一个或者多个从节点。

优势：
- 可以横向拓展写压力和存储压力，支持动态扩容和缩容，且操作简单，只需要添加节点到集群中即可。
- 具备主从复制、故障转移，Sentinel 机制等开箱即用的功能。

**2. Redis Cluster 如何分片，虚拟槽分区有什么优点**

Redis Cluser中，采用哈希槽分区，每一个键值对都属于一个hash slot（哈希槽），
客户端连接Redis Cluster中任意一个master节点即可访问Redis Cluster的数据，当客户端发送命令请求的时候，需要先根据key得到对应的哈希槽，然后查询哈希槽和节点的映射关系，即可找到目标节点。

如果哈希槽由当前节点负责，那就直接响应客户端的请求返回结果，如果不由当前节点负责，就会返回```-move```重定向错误，（Redis Cluster 内部重新分配哈希槽比如扩容缩容的时候，可能导致客户端缓存的哈希槽分配信息有误）告知客户端当前哈希槽是由哪个节点负责，客户端向目标节点发送请求并更新缓存的哈希槽分配信息。

优点：解耦了数据和节点之间的关系，提升了集群的横向拓展性和容错性

## 分布式锁