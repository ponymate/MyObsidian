## 基础

### 网络分层模型

![[weixin-mianznxjsjwllsewswztwxxssc-11ecdc9c-5a06-4429-bfc4-115793749000.jpg]]

1. 应用层

应用层协议定义的是应用进程间通信和交互的规则。

2. 传输层

提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。

3. 网络层

网络层是计算机网络中的一层，负责实现数据包的路由和转发，使得数据能够在不同网络之间传递。网络层的主要目标是在复杂的网络环境中确定数据包的最佳路径，并在中间节点上进行转发，实现端到端的通信。

-   **IP**
-   **ARP**：解决网络层地址和链路层地址之间的转换问题。
-   **ICMP**：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。
-   **NAT**：用于在私有网络和公共网络之间映射和转换 IP 地址，允许多个设备共享单个公共 IP 地址以访问互联网。NAT的主要目的是解决IPv4地址短缺的问题，同时提供一些网络安全和隐私的优势。
-   **OSPF**：一种内部网关协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。
-   **RIP**：一种内部网关协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。
-   **BGP**：用于自治系统（AS）之间交换路由信息的协议。具有高度的灵活性和可扩展性。

4. 数据链路层

数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。

5. 物理层

物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异
## DNS

DNS 要解决的是**域名和 IP 地址的映射问题**。**DNS 是应用层协议，基于 UDP 协议之上，端口为 53**

- 首先会查找浏览器的缓存,看看是否能找到对应的 IP 地址，找到就直接返回；否则进行下一步。
- 将请求发往给本地 DNS 服务器，如果查找到也直接返回，否则继续进行下一步；
- 本地 DNS 服务器向**根域名服务器**发送请求，根域名服务器返回负责`com`等顶级域名服务器的 IP 地址的列表。
- 本地 DNS 服务器再向顶级域名服务器发送一个请求，返回负责`baidu.com`的权限域名服务器的 IP 地址列表。
- 本地 DNS 服务器再向权限域名服务器发送一个请求，返回所对应的 IP 地址。

**DNS 解析过程**

DNS 的查询解析过程分为两种模式：**迭代，递归**。

![](https://oss.javaguide.cn/github/javaguide/cs-basics/network/DNS-process.png)

![](https://oss.javaguide.cn/github/javaguide/cs-basics/network/DNS-process2.png)

## Http

HTTP（Hypertext Transfer Protocol）是一种用于在Web浏览器和Web服务器之间传输数据的协议。它是互联网上最常用的协议之一，用于获取和呈现网页、图像、视频、音频等资源，以及在客户端和服务器之间进行通信。HTTP协议定义了客户端（通常是Web浏览器）和服务器之间的通信规则，允许用户在浏览器中输入URL来请求网页并获取内容。

### 请求过程

1. DNS 解析
2. TCP 三次握手建立连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. TCP四次挥手断开连接

### URI 和 URL 

1. **URI（统一资源标识符）：** 标识 Web 上每一种可用的资源，如 HTML 文档、图像、视频片段、程序等都是由一个 URI 进行标识的。
    
2. **URL（统一资源定位符）：** 它是 URI 的一种子集，主要作用是提供资源的路径。

URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

### 版本变化

**HTTP/1.0**

- 默认使用**短连接**，每次请求都需要建立一个 TCP 连接。它可以设置`Connection: keep-alive` 这个字段，强制开启长连接。

**HTTP/1.1**

- 引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用。
- 分块传输编码，即服务端每产生一块数据，就发送一块，用” 流模式” 取代” 缓存模式”。
- 管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。

**HTTP/2.0**

- 二进制协议，1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制。
- 完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。
- 报头压缩，HTTP 协议不带有状态，每次请求都必须附上所有信息。Http/2.0 引入了头信息压缩机制，使用 gzip 或 compress 压缩后再发送。
- 服务端推送，允许服务器未经请求，主动向客户端发送资源。

### HTTPS 

1. HTTP是一种普通的文本协议，数据在传输过程中是明文的，容易被窃听和篡改。HTTPS通过使用TLS（Transport Layer Security）或SSL（Secure Sockets Layer）协议进行加密，确保数据在传输过程中被加密，提供更高的安全性。
2. HTTP 默认使用80端口。HTTPS 默认使用443端口。
3. HTTP 不需要证书，HTTPS 需要使用SSL证书，用于在客户端和服务器之间建立安全连接，验证服务器的身份。
4. HTTP 由于数据没有加密处理，传输速度可能较快。HTTPS 由于数据需要加密和解密，可能会稍微减慢传输速度，但随着加密技术的改进，影响已经减小。

HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决了这些风险：

- **信息加密**：交互信息⽆法被窃取。
- **校验机制**：⽆法篡改通信内容，篡改了就不能正常显示。
- **身份证书**：能证明淘宝是真淘宝。

HTTPS 主要工作流程：

1. 客户端发起 HTTPS 请求，连接到服务端的 443 端口。
2. 服务端有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。
3. 服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。
4. 客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。
5. 客户端将公钥加密后的密钥发送到服务器。
6. 服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。
7. 服务器将加密后的密文返回到客户端。
8. 客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。

![https 工作流程详图](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-c0e6e3e1-b4a2-41de-97ac-4103db2f2fc5.jpg)
### Cookie 和 Session

HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议中服务端不会保存客户端的任何信息。

- Cookie 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。服务端可以根据这个 Cookie 判断用户的身份和状态。Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能。

- Session 指的就是服务器和客户端一次会话的过程。session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息记录在服务器上，这就是 session。客户端浏览器再次访问时只需要从该 session 中查找用户的状态。Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。

> Session 和 Cookie 有什么关联呢？

可以使用 Cookie 记录 Session 的标识。

![Session 和 Cookie 的关联](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-419362c7-955e-44b5-b40e-224bb3dbc6b6.jpg)

Session 和 Cookie 的关联

- 用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。
- 当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

> **客户端无法使用 Cookie 怎么办？**

有可能客户端无法使用 Cookie，比如浏览器禁用 Cookie，或者客户端是安卓、IOS 等等。

首先是 SessionID 的存储，可以使用客户端的本地存储，比如浏览器的 sessionStorage。

接下来怎么传呢？

- 拼接到 URL 里：直接把 SessionID 作为 URL 的请求参数
- 放到请求头里：把 SessionID 放到请求的 Header 里，比较常用。
## TCP UDP

### 对比

-   **是否面向连接**：UDP 在传送数据之前不需要先建立连接，而 TCP 提供面向连接的服务。
-   **是否是可靠传输**：UDP 不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务保证数据无差错、不丢失、不重复、并且按序到达。
-   **传输效率**：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。
-   **首部开销**：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。
-   **是否提供广播或多播服务**：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多。
-   **传输形式**：TCP 是面向字节流的，UDP 是面向报文的。
	
	- 当用户消息通过 UDP 协议传输时，操作系统不会对消息进行拆分，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是每个 UDP 报文就是一个用户消息的边界，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。
	
	- 当用户消息通过 TCP 协议传输时，**消息可能会被操作系统分组成多个的 TCP 报文**，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。**我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议**。

-   **UDP 一般用于即时通信**，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。例如：**DHCP 协议**（动态主机配置协议，动态配置 IP 地址）、**DNS** 

-   **TCP 用于对传输准确性要求特别高的场景**，比如文件传输、发送和接收邮件、远程登录等等。例如：**HTTP 协议** 、 **HTTPS 协议** 、**FTP 协议**、 **SMTP 协议**、**POP3/IMAP 协议**、**SSH 协议**。

### 三次握手和四次挥手

**建立连接-TCP 三次握手**

![[weixin-mianznxjsjwllsewswztwxxssc-f95c3cbb-cf2d-4444-9878-44ec076beb86 1.jpg]]


-  最开始，客户端和服务端都处于 CLOSE 状态，服务端监听客户端的请求，进入 LISTEN 状态
-   **一次握手**：客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 **SYN_SEND** 状态，等待服务器的确认；
-   **二次握手**：服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端，然后服务端进入 **SYN_RECV** 状态
-   **三次握手**：客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务器端都进入**ESTABLISHED** 状态，完成TCP三次握手。

三次握手的目的是建立可靠的通信信道，让双方确认自己与对方的发送与接收是正常的。

能接收到对方的恢复，表明自己和对方的发送和接受都是正常的。客户端接收到回复，说明自己的发送和接收，对方的发送和接收都没问题，服务端同理。

第 3 次握手是可以携带数据的。

此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。

第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在 SYN 报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成 CPU 和内存的消耗。

**断开连接-TCP 四次挥手**

![TCP 四次挥手](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ba156295-03af-46dc-8ef3-869b44b11303.jpg)

1.  **第一次挥手** ：客户端发送一个 FIN（SEQ=X） 标志的数据包->服务端，关闭客户端到服务器的数据传送，客户端进入 **FIN-WAIT-1** 状态。
2.  **第二次挥手** ：服务器收到数据包后，发送一个 ACK （SEQ=X+1）标志的数据包->客户端 。此时服务端进入**CLOSE-WAIT**状态，客户端进入**FIN-WAIT-2**状态。
3.  **第三次挥手** ：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，关闭服务端到客户端的连接，服务端进入**LAST-ACK**状态。
4.  **第四次挥手** ：客户端收到数据包后，发送 ACK (SEQ=y+1)标志的数据包->服务端并且进入**TIME-WAIT**状态，服务端在收到回复的数据包后进入 **CLOSE** 状态。此时，如果客户端等待 **2MSL** 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。

**只要四次挥手没有结束，客户端和服务端就可以继续传输数据！**

TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

举个例子：A 和 B 打电话，通话即将结束后。

1.  **第一次挥手** ： A 说“我没啥要说的了”
2.  **第二次挥手** ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话
3.  **第三次挥手** ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”
4.  **第四次挥手** ：A 回答“知道了”，这样通话才算结束。

> **为什么需要等待？**

**1. 为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。** 这个 ACK 报文段有可能丢失，因而使处在 **LAST-ACK** 状态的服务端就收不到对已发送的 **FIN + ACK** 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（**超时 + 1MSL 传输**）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 **CLOSED** 状态。

**2. 防止已失效的连接请求报文段出现在本连接中**。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

### 半连接队列和 SYN Flood 攻击

> **什么是半连接队列？**

TCP 进入三次握手前，服务端会从 **CLOSED** 状态变为 **LISTEN** 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。

![三次握手中创建的队列](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-f95c3cbb-cf2d-4444-9878-44ec076beb86.jpg)

顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。

- TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 **ACK 和 SYN**，状态由 **LISTEN 变为 SYN_RCVD**，此时这个连接就被推入了 **SYN 队列**，即半连接队列。
- 当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。

> **什么是 SYN Flood ？**

SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造**不存在的 IP 地址**, 向服务器发送大量 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 **SYN** 接收队列（半连接队列），使得服务器不能为正常⽤户服务。

> **那有什么应对方案呢？**

主要有 **syn cookie** 和 **SYN Proxy 防火墙**等。

- **syn cookie**：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。
- **SYN Proxy 防火墙**：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接

### TCP 可靠传输

**TCP 如何保证传输的可靠性？**

1.  **基于数据块传输**：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。
2.  **序列号/确认应答**：TCP 给发送的每一个包进行编号，接收方会对收到的包进行应答，发送方就会知道接收方是否收到对应的包，如果发现没有收到，就会重发，这样就能保证数据的完整性。并且可以去掉重复序列号的数据实现去重。
3.  **校验和**：TCP 将保持它首部和数据的检验和，检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4.  **超时重传**：当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果在RTT内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。
5.  **流量控制**：TCP 利用滑动窗口实现流量控制。TCP 连接的每一方都有固定大小的缓冲空间，发送端只能发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，提示发送方降低发送的速率，防止包丢失。
6.  **拥塞控制**：当网络拥塞时，减少数据的发送。

### TCP 流量控制

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。

**TCP 发送窗口可以划分成四个部分** ：

1.  已经发送并且确认的TCP段；
2.  已经发送但是没有确认的TCP段；
3.  未发送但是接收方准备接收的TCP段；
4.  不可发送；

![TCP发送窗口结构](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-send-window.png)

**TCP 接收窗口可以划分成三个部分** ：

1.  已经接收并且已经确认的 TCP 段；
2.  可以接收未确认的 TCP 段；
3.  不可接收的 TCP段（）。

![TCP接收窗口结构](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-receive-window.png)

**接收窗口的大小是根据接收端处理数据的速度动态调整的。** 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。

### TCP 拥塞控制

拥塞控制就是为了防止过多的数据注入到网络中，防止网络中的路由器或链路过载。
拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

>拥塞的两种情况

1. 某个段超时了（丢失事件）：拥塞
- 原因1：网络拥塞（某个路由器缓存区没空间了，被丢弃）概率大
- 原因2：出错被丢弃了（各级错误，没有通过校验，被丢弃）概率小
一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的

2. 有关某个段的3次重复ACK：轻微拥塞
![[Pasted image 20230517130534.png]]
- 段的第1个ack，正常，确认绿段，期待红段
- 段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达
- 段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了，橙段乱序到达，同时红段丢失的可能性很大
网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好

>拥塞窗口

![TCP的拥塞控制](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-congestion-control.png)

TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

>拥塞控制的算法

TCP 的拥塞控制采用了三种算法，即 **慢启动** 、 **拥塞避免** 、**拥塞发生**、**快速恢复**。

当cwnd < Threshold，发送端处于慢启动阶段，窗口指数性增长
当cwnd > Threshold，发送端处于拥塞避免阶段，窗口线性增长

>拥塞发生后的措施，拥塞发生算法的两种情况

第一种情况：如果发生了超时丢包事件时，说明拥塞严重。

- 慢启动阀值 sshthresh = cwnd /2
- cwnd 重置为 1
- 进入新的慢启动过程

第二种情况：当收到 3 个冗余 ACK 指示的丢包事件时，说明轻度拥塞。

- 拥塞窗口大小 cwnd = cwnd/2
- 慢启动阀值 ssthresh = cwnd
- 进入快速恢复算法

>快速恢复

快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。

正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新：

- cwnd = cwnd /2
- sshthresh = cwnd

然后，进⼊快速恢复算法如下：

- cwnd = sshthresh + 3
- 重传重复的那几个 ACK（即丢失的那几个数据包）
- 如果再收到重复的 ACK，那么 cwnd = cwnd +1
- 如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。

![[Pasted image 20230517132318.png]]

![[Pasted image 20230517132158.png]]

### TCP 的重传机制

重传包括**超时重传、快速重传、带选择确认的重传（SACK）、重复 SACK 四种**。

>超时重传

超时重传，是 TCP 协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。

超时重传不是十分完美的重传方案，它有这些缺点：

- 当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。
- 当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。

>快速重传

它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。

如果连续收到了三个相同的ACK，就说明数据丢失了，需要进行重传。

快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题。

>带选择确认的重传（SACK）

为了解决应该重传多少个包的问题? TCP 提供了**带选择确认的重传**（即 SACK，Selective Acknowledgment）。

**SACK 机制**就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包。

>重复 SACK（D-SACK）

D-SACK，英文是 Duplicate SACK，是在 SACK 的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。

返回的ACK序号之前的包都是接收到的。

## 网络层
### IP

**IP（Internet Protocol，网际协议）**，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。

目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。

每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 **IP 地址**，作为唯一标识符。每个 IP 地址都是一个字符序列。当网络设备发送 IP 数据包时，数据包中包含了 **源 IP 地址** 和 **目的 IP 地址** 。网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。

### Ping

PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。

PING 命令的输出结果通常包括以下几部分信息：

1.  **ICMP Echo Request（请求报文）信息**：序列号、TTL（Time to Live）值。
2.  **目标主机的域名或 IP 地址**：输出结果的第一行。
3.  **往返时间（RTT，Round-Trip Time）**：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。
4.  **统计结果（Statistics）**：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。

如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题。如果往返时间（RTT）过高，则表明网络延迟过高。

PING 基于网络层的 **ICMP（Internet Control Message Protocol，互联网控制报文协议）**，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。

ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：

-   **查询报文类型**：向目标主机发送请求并期望得到响应。
-   **差错报文类型**：向源主机发送错误信息，用于报告网络中的错误情况。

PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。

-   PING 命令会向目标主机发送 ICMP Echo Request。
-   如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。

### NAT

**NAT 协议（Network Address Translation）** 网络地址转换。如果每个主机都有一个“绝对唯一”的 IP 地址，那么 IPv4 地址的表达能力可能很快达到上限（$2^{32}$）。因此，实际上， 子网中的 IP 地址是“相对的”，这在一定程度上也缓解了 IPv4 地址的分配压力。子网的“代理人”，通常由路由器扮演。路由器的 LAN 一侧管理着一个小子网，而它的 WAN 接口才是真正参与到 Internet 中的接口，也就有一个“绝对唯一的地址”。NAT 协议，正是在 LAN 中的主机在与 LAN 外界通信时，起到了地址转换的关键作用。

假设当前场景如上图。中间是一个路由器，它的右侧组织了一个 LAN，网络号为`10.0.0/24`。LAN 侧接口的 IP 地址为`10.0.0.4`，并且该子网内有至少三台主机，分别是`10.0.0.1`，`10.0.0.2`和`10.0.0.3`。路由器的左侧连接的是 WAN，WAN 侧接口的 IP 地址为`138.76.29.7`。

首先，针对以上信息，我们有如下事实需要说明：

1.  路由器的右侧子网的网络号为`10.0.0/24`，主机号为`10.0.0/8`，三台主机地址，以及路由器的 LAN 侧接口地址，均由 DHCP 协议规定。而且，该 DHCP 运行在路由器内部（路由器自维护一个小 DHCP 服务器），从而为子网内提供 DHCP 服务。
2.  路由器的 WAN 侧接口地址同样由 DHCP 协议规定，但该地址是路由器从 ISP（网络服务提供商）处获得，也就是该 DHCP 通常运行在路由器所在区域的 DHCP 服务器上。

现在，路由器内部还运行着 NAT 协议，从而为 LAN-WAN 间通信提供地址转换服务。为此，一个很重要的结构是 **NAT 转换表**。为了说明 NAT 的运行细节，假设有以下请求发生：

1.  主机`10.0.0.1`向 IP 地址为`128.119.40.186`的 Web 服务器（端口 80）发送了 HTTP 请求。此时，主机`10.0.0.1`将随机指派一个端口，如`3345`，作为本次请求的源端口号，将该请求发送到路由器中（目的地址将是`128.119.40.186`，但会先到达`10.0.0.4`）。
2.  `10.0.0.4`即路由器的 LAN 接口收到`10.0.0.1`的请求。路由器将为该请求指派一个新的源端口号，如`5001`，并将请求报文发送给 WAN 接口`138.76.29.7`。同时，在 NAT 转换表中记录一条转换记录**138.76.29.7:5001——10.0.0.1:3345**。
3.  请求报文到达 WAN 接口，继续向目的主机`128.119.40.186`发送。

之后，将会有如下响应发生：

1.  主机`128.119.40.186`收到请求，构造响应报文，并将其发送给目的地`138.76.29.7:5001`。
2.  响应报文到达路由器的 WAN 接口。路由器查询 NAT 转换表，发现`138.76.29.7:5001`在转换表中有记录，从而将其目的地址和目的端口转换成为`10.0.0.1:3345`，再发送到`10.0.0.4`上。
3.  被转换的响应报文到达路由器的 LAN 接口，继而被转发至目的地`10.0.0.1`。

-   NAT 协议通过对 WAN 屏蔽 LAN，有效地缓解了 IPv4 地址分配压力。
-   LAN 主机 IP 地址的变更，无需通告 WAN。
-   WAN 的 ISP 变更接口地址时，无需通告 LAN 内主机。
-   LAN 主机对 WAN 不可见，不可直接寻址，可以保证一定程度的安全性。


### ARP

MAC 地址的全称是 **媒体访问控制地址（Media Access Control Address）**。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。

ARP 协议，全称 **地址解析协议（Address Resolution Protocol）**，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，当主机发送 IP 数据报文时（网络层），仅知道目的地的 IP 地址，并不清楚目的地的 MAC 地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。

在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 `<IP, MAC, TTL>` 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。

ARP 的工作原理将分两种场景讨论：

1.  **同一局域网内的 MAC 寻址**；
2.  **从一个局域网到另一个局域网中的网络设备的寻址**。

**1.同一局域网内的 MAC 寻址**

假设当前有如下场景：IP 地址为`137.196.7.23`的主机 A，想要给同一局域网内的 IP 地址为`137.196.7.14`主机 B，发送 IP 数据报文。

1.  主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，也就无从知道主机 B 的 MAC 地址。
    
2.  主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。每一个设备都会收到该分组，并检查接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效。
    
    ARP 分组是一种特殊报文，ARP 分组有两类，一种是查询分组，另一种是响应分组，它们具有相同的格式，均包含了发送和接收的 IP 地址、发送和接收的 MAC 地址。查询分组中，发送方 IP 地址为 A 的 IP 地址，接收方 IP 地址为 B 的 IP 地址，发送方 MAC 地址为主机 A 的 MAC 地址，接收的 MAC 地址为 `FF-FF-FF-FF-FF-FF`，该 MAC 地址是广播地址，也就是说，查询分组将广播给该局域网内的所有设备。
    
3.  主机 B 收到了查询分组之后，验证是对自己的问询，接着构造一个 ARP 响应分组，发送给主机 A。同时，主机 B 提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录。
    
4.  主机 A 收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，将信息加入到自己的 ARP 表中。

总结来说，ARP 协议是一个**广播问询，单播响应**协议。

**2.不同局域网内的 MAC 寻址**

路由器作为互联设备，具有多个接口，每个接口同样也应该具备不重复的 IP 地址和 MAC 地址。因此，在讨论 ARP 表时，路由器的多个接口都各自维护一个 ARP 表，而非一个路由器只维护一个 ARP 表。

1.  主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址，未能找到，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。
    
    目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报文转发到 B 所在子网的那个路由器。
    
2.  主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是**本子网内与路由器连接的接口的 MAC 地址**。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。
    
3.  目标接口接收到了主机 A 发过来的链路层帧，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。
    
4.  路由器接口查询 ARP 表，寻找主机 B 的 MAC 地址，未能找到主机 B 的 MAC 地址，将采用 ARP 协议，获取主机 B 的 MAC 地址。
    
5.  路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。