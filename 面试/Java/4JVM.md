1. JVM 内存结构
2. 栈中存放什么数据，堆中呢？
3. 大对象放在哪个内存区域
4. 堆区如何分类，如何分配内存
5. 判断对象是否死亡
6. 垃圾回收有哪些算法
7. GC 的全流程
8. GC 中老年代用什么回收方法？
9. 垃圾收集器
10. 什么是类加载？何时类加载？类加载流程？
11. 知道哪些类加载器。类加载器之间的关系？
12. 双亲委派
13. JVM 调优参数

![[Pasted image 20230715141335.png]]
## Java内存结构

**JDK 1.8 之前** ：

![[java-runtime-data-areas-jdk1.7.png]]

**JDK 1.8 之后** ：

![[java-runtime-data-areas-jdk1.8.png]]

### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。

-   字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
-   在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

⚠️ 注意 ：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### 虚拟机栈

Java 虚拟机栈是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。

Java 方法调用都是通过栈来实现的，除了一些 Native 方法调用是通过本地方法栈实现的。

方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。

栈帧（Stack Frame）：每个线程在执行方法时，都会创建对应的栈帧，用于存储方法的局部变量表、操作数栈、动态链接、方法出口等信息。栈帧的创建和销毁与方法的调用和返回密切相关。

![[stack-area.png]]

**局部变量表** 用于存储方法中的局部变量和方法参数。局部变量表的每个槽位可以容纳一个基本数据类型或对象引用。

**操作数栈** 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

**动态链接** 动态链接是指在方法调用过程中将符号引用转换为实际的方法入口地址的过程。在Java中，方法的调用是基于动态绑定的，也就是说方法调用的目标可能在编译时无法确定，需要在运行时进行解析。

**方法出口** 用于记录方法的返回地址，即方法执行完成后需要返回到哪个位置继续执行。

![[jvmimage-20220331175738692.png]]

简单总结一下程序运行中栈可能会出现两种错误：

-   **`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
-   **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

### 本地方法栈

在Java中，本地方法（Native Method）是指使用非Java语言（如C、C++等）编写的方法。本地方法允许Java程序与底层系统或其他非Java代码进行交互。

在Java中，本地方法的声明由`native`关键字修饰，它只有方法的声明而没有实现。本地方法的实现需要在本地代码中完成，并通过JNI和Java代码进行关联。Java程序通过JNI接口调用本地方法。

本地方法允许直接访问底层系统资源，如操作系统的API、硬件设备等。这使得Java程序可以利用本地方法获得更高的性能或访问特定的底层功能。

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

### 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 世界中“几乎”所有的对象都在堆中分配，但是，从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用，那么对象可以直接在栈上分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为：

1.  新生代(Young Generation)，新生代分为 Eden 区、两个 Survivor 区 S0 和 S1 
2.  老生代(Old Generation)

堆这里最容易出现的就是 `OutOfMemoryError` 错误

### 字符串常量池

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

字符串常量池中存储的是字符串对象。字符串常量池中包含一个 `StringTable` ，用于实现字符串常量池的管理和维护。它通常是基于哈希表（HashTable）的数据结构，用于快速查找和存储字符串对象。

**`StringTable` 中保存的是字符串对象的引用，字符串对象的引用指向字符串常量池中的字符串对象。**

JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在Full GC的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

### 方法区

方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。

当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

**方法区和永久代以及元空间是什么关系呢？** 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。

![[method-area-implementation.png]]

**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**

整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

### 运行时常量池

运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。

Java 的运行时常量池（Runtime Constant Pool）是一块位于方法区的内存区域，用于存储编译时期生成的各种字面量（Literal）和符号引用（Symbolic References）。

1. 存储字面量：运行时常量池存储了编译时期生成的字符串字面量、数字字面量、布尔值等字面量。这些字面量可以直接被引用和使用，而无需再次创建和初始化。
    
2. 存储符号引用：符号引用是指在编译时期生成的、用于描述类、方法、字段等符号的字符串符号。运行时常量池中存储了类的全限定名、方法的名称和描述符、字段的名称和描述符等符号引用。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 错误。

### 对象创建的过程

在 JVM 中对象的创建，我们从一个 new 指令开始：

- 首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用
    
- 检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程
    
- 类加载检查通过后，接下来虚拟机将为新生对象分配内存。
    
- 内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。
    
- 接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。

这个过程大概图示如下：

![对象创建过程](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-9.png)

### 对象的内存布局

在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

![对象的存储布局](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-12.png)

**对象头**主要由两部分组成：

- 第一部分存储对象自身的运行时数据：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，官方称它为 Mark Word，它是个动态的结构，随着对象状态变化。
- 第二部分是类型指针，指向对象的类元数据类型（即对象代表哪个类）。
- 此外，如果对象是一个 Java 数组，那还应该有一块用于记录数组长度的数据

**实例数据**用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。

**对齐填充**不是必须的，没有特别含义，仅仅起着占位符的作用。

### 对象访问定位

Java 程序会通过栈上的 reference 数据来操作堆上的具体对象。主流的访问方式主要有使用句柄和直接指针两种：

- 如果使用句柄访问的话，Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示：

![通过句柄访问对象](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-13.png)


- 如果使用直接指针访问的话，Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示：

![通过直接指针访问对象](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-14.png)


这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。

使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。

HotSpot 虚拟机主要使用直接指针来进行对象访问。

### 内存溢出内存泄漏

内存泄露就是申请的内存空间没有被正确释放，导致内存被白白占用。

内存溢出就是申请的内存超过了可用内存，内存不够了。

>内存泄漏的原因

1. **静态集合类引起内存泄漏**

静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。

2. **单例模式**

和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。

3. **数据连接、IO、Socket 等连接**

创建的连接不再使用时，需要调用 **close** 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。

4. **变量不合理的作用域**

一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。

5. **hash 值发生变化**

对象 Hash 值改变，使用 HashMap、HashSet 等容器中时候，由于对象修改之后的 Hah 值和存储进容器时的 Hash 值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。

**ThreadLocal 使用不当**

ThreadLocal 的弱引用导致内存泄漏也是个老生常谈的话题了，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。

### 对象引用类别

Java 中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。

- 强引用是最传统的`引用`的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。

```Java
Object obj =new Object();
```

- 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在 JDK 1.2 版之后提供了 SoftReference 类来实现软引用。

```Java
Object obj = new Object();
ReferenceQueue queue = new ReferenceQueue();
SoftReference reference = new SoftReference(obj, queue);
//强引用对象滞空，保留软引用
obj = null;
```

- 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 版之后提供了 WeakReference 类来实现弱引用。

```Java
Object obj = new Object();
ReferenceQueue queue = new ReferenceQueue();
WeakReference reference = new WeakReference(obj, queue);
//强引用对象滞空，保留弱引用
obj = null;
```

- 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。

```Java
Object obj = new Object();
ReferenceQueue queue = new ReferenceQueue();
PhantomReference reference = new PhantomReference(obj, queue);
//强引用对象滞空，保留虚引用
obj = null;
```

### finalize()方法

如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize()方法。如果对象在在 finalize()重新与引用链上的任何一个对象建立关联，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。
## JVM 垃圾回收

### 死亡对象判断方法

1. 引用计数法

给对象中添加一个引用计数器：

-   每当有一个地方引用它，计数器就加 1；
-   当引用失效，计数器就减 1；
-   任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。**

2. 可达性分析算法

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

**哪些对象可以作为 GC Roots 呢？**

-   栈中引用的对象
-   方法区中类静态属性引用的对象
-   方法区中常量引用的对象
-   所有被同步锁持有的对象

### 垃圾收集算法

1. 标记-清除算法

该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

这种垃圾收集算法会带来两个明显的问题：

1.  **效率问题**：如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。
2.  **空间问题**：标记清除后会产生大量不连续的碎片。

2. 标记-复制算法

为了解决效率问题，它将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

虽然改进了标记-清除算法，但依然存在下面这些问题：

-   **可用内存变小** ：可用内存缩小为原来的一半。
-   **不适合老年代** ：如果存活对象数量比较大，复制性能会变得很差。

3. 标记-整理算法

根据老年代的特点提出的一种标记算法，首先标记出所有不需要回收的对象，然后让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。

### GC分类和原则

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：
	
- 部分收集 (Partial GC)：
	-   新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
	-   老年代收集（Major GC / Old GC）：指目标只是老年代的垃圾收集。目前**只有**CMS 收集器会有单独收集老年代的行为。
	-   混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。
- 整堆收集 (Full GC)：收集整个 Java 堆和方法区。

>Minor GC 的时机

大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起Minor GC。

> Full GC 的时机

- **Young GC 之前检查老年代**：在要进行 Young GC 的时候，发现`老年代可用的连续内存空间` < `新生代历次Young GC后升入老年代的对象总和的平均大小`，说明本次 Young GC 后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。
- **Young GC 之后老年代空间不足**：执行 Young GC 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次 Full GC
- **老年代空间不足**，老年代内存使用率过高，达到一定比例，也会触发 Full GC。
- **空间分配担保失败**（ Promotion Failure），新生代的 Survivor 放不下从 Eden 拷贝过来对象，会提前将Survivor 中的对象放入老年代，老年代如果放不下的话都会触发 Full GC。
- **方法区内存空间不足**：如果方法区由永久代实现，永久代空间不足 Full GC。
- **System.gc()等命令触发**：System.gc()、jmap -dump 等命令会触发 full gc。

>对象什么时候会进入老年代?

**大对象直接进入老年代**

大对象直接进入老年代，比如：字符串、数组等需要大量连续内存空间的对象，避免分配担保机制带来的复制而降低效率。

**长期存活的对象将进入老年代**

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到15（默认），就会被晋升到老年代中。

**空间分配担保**

假如在 Young GC 之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代

**动态对象年龄判定**

为了能更好地适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到设定值才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

### 垃圾收集器

![HotSpot虚拟机垃圾收集器](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-28.png)

1. Serial

Serial 是一个新生代收集器，单线程工作，使用 标记-复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程（ "Stop The World" ）。

![[Pasted image 20230716175917.png]]

2. ParNew

ParNew 收集器其实就是 Serial 收集器的多线程版本，是一个新生代收集器，使用多条线程进行垃圾收集。

ParNew 采用标记-复制算法

![[Pasted image 20230716175927.png]]

3. Parallel Scavenge

Parallel Scavenge 是一个新生代收集器，采用 标记-复制算法，是并行的多线程收集器。和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU 用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。

JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old

4. Serial Old

Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。

5. Parallel Old 收集器

Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。

![[Pasted image 20230716175936.png]]

4. CMS 收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，同样是老年代的收集器，采用标记-清除算法。

特点：

- 低延迟： 减少STW对用户体验的影响【响应时间和延迟要求高】
- 并发收集：可以同时执行用户线程
- CMS收集器 不能像其他收集器那样等到老年代几乎完全被填满了再进行收集 ，而是当堆内存使用率达到某一阈值时，便开始进行回收。
- CMS收集器的垃圾收集算法采用的是标记清除算法，会产生内存碎片。
- CMS收集器对CPU资源非常敏感。

运行步骤：

-   **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
-   **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
-   **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
-   **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。
  
![[Pasted image 20230716175955.png]]

5. G1 收集器

jdk1.9 默认垃圾收集器

Garbage First（简称 G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于 Region 的内存布局形式。

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

- 并行与并发：充分利用多CPU、多核环境下的硬件优势
- 分代收集：不需要其他收集器配合就能独立管理整个GC堆
- 空间整合：“标记—整理”算法实现的收集器，局部上基于“复制”算法不会产生内存空间碎片
- 可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**：标记GC Roots能直接关联到的对象，需要停顿线程，但耗时很短
- **并发标记**：是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行
- **最终标记**：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录
- **筛选回收**：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划

![[Pasted image 20230716180004.png]]

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率。

## 类

### 类加载过程

![[Pasted image 20230716180014.png]]

系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。

![[Pasted image 20230716180022.png]]

1. **加载**

类加载过程的第一步，主要完成下面 3 件事情：

1.  通过全类名获取定义此类的二进制字节流
2.  将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3.  在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口

一个非数组类的加载阶段是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。

加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

2. **验证**

![[Pasted image 20230716180030.png]]

3. **准备**

**主要内容是为类变量分配内存并设置初始值**，类变量所使用的内存都应当在 **方法区** 中进行分配。

这里所设置的初始值"通常情况"下是数据类型默认的零值（如 0、0L、null、false 等），除非变量加上了 final 关键字 `public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

4. **解析**

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

5. **初始化**

初始化阶段是执行初始化方法的过程，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，才对类进行初始化（只有主动去使用类才会初始化类）：

1.  当遇到 `new` 、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条直接码指令时，比如 `new` 一个类，读取和设置一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
2.  使用 `java.lang.reflect` 包的方法对类进行反射调用时如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
3.  初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4.  当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。
5.  `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类。

6. **卸载**

卸载类即该类的 Class 对象被 GC。

卸载类需要满足 3 个要求:

1.  该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2.  该类没有在其他任何地方被引用
3.  该类的类加载器的实例已被 GC

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

### 类加载器

所有的类都由类加载器加载，加载的作用就是将 `.class`文件加载到内存。

-   类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。
-   每个 Java 类都有一个引用指向加载它的 `ClassLoader`。
-   数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。

JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。

对于已经加载的类会被放在 `ClassLoader` 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，对于一个类加载器来说，相同二进制名称的类只会被加载一次。

JVM 中内置了三个重要的 `ClassLoader`，除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自 `java.lang.ClassLoader`：

1.  `BootstrapClassLoader`(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。
2.  `ExtensionClassLoader`(扩展类加载器) ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。
3.  `AppClassLoader`(应用程序类加载器) ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

### 双亲委派模型

-   `ClassLoader` 类使用双亲委派模型来搜索类和资源。
-   双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
-   `ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

下图展示的各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型(Parents Delegation Model)**”。

![[Pasted image 20230716180039.png]]

简单总结一下双亲委派模型的执行流程：

-   在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
-   类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
-   只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。

双亲委派模型可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改。